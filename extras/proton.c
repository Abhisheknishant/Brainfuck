#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/*
 *  Proton.
 *
 *  A simple 'pcode' implementation of a brainfuck interpreter.
 *
 *  The compile stage is divided into two phases, phase one works with
 *  the BF language itself and identifies runs of instructions and loops
 *  that can never be run (comment loops) it also ensures all loops
 *  are properly balanced by adding or ignoring ']' commands. Phase two
 *  converts the runs generated by the first phase into 'instructions'
 *  consisting of two or three integers, a pointer movement, a command and
 *  and optional argument. These values are stored into an array and the
 *  loops start and end tokens are linked together using relative jumps.
 *
 *  The runner is a very tight while/switch loop.
 *
 *  The CELLTYPE and CELLBITS macros allow you to change the type of the
 *  tape cells, the bits value can be anything from about 6 to the size
 *  of the type specified. If the CELLBITS is not specified the base type
 *  is used unmasked.
 *
 *  If CELLBITS less than 7 only decimal output is implemented.
 *
 *  The default memory size may be defined with the MEMSIZE define.
 *
 *  This is pure ANSI C '89 and may be compiled like this:
 *
 *  gcc -O -Wall -Wshadow -Wextra -ansi -pedantic  -o proton proton.c
 */

#if !defined(CELLTYPE) && defined(CELLBITS)
#define CELLTYPE int
#endif
#ifndef CELLTYPE
typedef unsigned char icell;
#define M(x) (x)
#else
typedef CELLTYPE icell;
#ifdef CELLBITS
#define M(x) ((x)&(icell)((2UL << (CELLBITS)-1) -1))
#else
#define M(x) (x)
#endif
#endif

void outcmd(int ch, int count);
void runprog(void);
void dumpmem(icell *tp);

int enable_debug;
int do_dump = 0;
int on_eof = 1;

#ifndef MEMSIZE
#define MEMSIZE 65536
#endif
int *mem = 0, *mptr = 0, memlen = 0;
struct stkdat { struct stkdat * up; int id; } *sp = 0;
int imov = 0;

icell * tape = 0;

#define TOKEN_LIST(Mac) \
    Mac(STOP) Mac(ADD) Mac(PRT) Mac(INP) Mac(WHL) Mac(END) Mac(DUMP)

#define GEN_TOK_ENUM(NAME) T_ ## NAME,
enum token { TOKEN_LIST(GEN_TOK_ENUM) TCOUNT};
#define GEN_TOK_STRING(NAME) #NAME,
const char* tokennames[] = { TOKEN_LIST(GEN_TOK_STRING) };

int
main(int argc, char ** argv)
{
    char * pgm = argv[0];
    int ch, lastch=']', c=0, m, b=0, lc=0;
    FILE * ifd;

    for(;;) {
	if (argc < 2 || argv[1][0] != '-' || argv[1][1] == '\0') {
	    break;

	} else if (!strcmp(argv[1], "-d")) {
	    enable_debug++; argc--; argv++;
	} else if (!strcmp(argv[1], "-e")) {
	    on_eof = -1; argc--; argv++;
	} else if (!strcmp(argv[1], "-z")) {
	    on_eof = 0; argc--; argv++;
	} else if (!strcmp(argv[1], "-n")) {
	    on_eof = 1; argc--; argv++;
	} else if (!strcmp(argv[1], "-h") || !strcmp(argv[1], "--help")) {

	    fprintf(stderr, "%s: [options] [File]\n", pgm);
	    fprintf(stderr, "%s\n",
	    "\t"    "-h      This message"
	    "\n\t"  "-e      End of EOF for ',' command sets cell to 255"
	    "\n\t"  "-z      End of EOF for ',' command sets cell to Zero"
	    "\n\t"  "-n      End of EOF for ',' command leaves cell unchanged"
	    "\n\t"  "-d      Debug mode, enable '#' command.");
	    exit(0);

	} else if (strcmp(argv[1], "--") == 0) {
	    argc--; argv++;
	    break;
	} else if (argv[1][0] == '-') {
	    fprintf(stderr, "Unknown option '%s'; use -h for an option list\n",
		    argv[1]);
	    exit(1);
	} else break;
    }
    if (argc<=1 || strcmp(argv[1], "-") == 0) {
	ifd = stdin;
    } else if((ifd = fopen(argv[1],"r")) == 0) {
	perror(argv[1]); exit(1);
    }

    /* For every character from the input ending with EOF
     * PLUS if it's the stdin the '!' ends the program too */
    while((ch = fgetc(ifd)) != EOF && (ifd!=stdin || ch != '!')) {
	/* These chars are RLE */
	m = (ch == '>' || ch == '<' || ch == '+' || ch == '-');
	/* These ones are not */
	if(!m && ch != '[' && ch != ']' && ch != '.' && ch != ',' &&
	    /* Allow the debug symbol only if it's enabled */
	    (ch != '#' || !enable_debug)) continue;
	/* Check for loop comments; ie: ][ comment ] */
	if (lc || (ch=='[' && lastch==']')) { lc += (ch=='[') - (ch==']'); continue; }
	if (lc) continue;
	/* Do the RLE */
	if (m && ch == lastch) { c++; continue; }
	/* Post the RLE token onward */
	if (c) outcmd(lastch, c);
	c = m;
	if (!m) {
	    /* Non RLE tokens here */
	    if (!b && ch == ']') continue; /* Ignore too many ']' */
	    b += (ch=='[') - (ch==']');
	    /* Found a trivial infinite loop; abort it. */
	    if (lastch == '[' && ch == ']') outcmd('X', 1);
	    outcmd(ch, 1);
	}
	lastch = ch;
    }
    if (ifd != stdin) fclose(ifd);
    if(c) outcmd(lastch, c);
    while(b>0){ outcmd(']', 1); b--;} /* Not enough ']', add some. */
    if (enable_debug) outcmd('#', 0);
    outcmd('X', 0);

    if (!(tape = calloc(MEMSIZE, sizeof(icell)))) {
	perror("Allocating tape array"); exit(1);
    }

    setbuf(stdout, 0);
    runprog();
    return 0;
}

void
outcmd(int ch, int count)
{
    if (memlen < mptr-mem + 8) {
	size_t s = memlen + 8192;
	int * p;
	p = realloc(mem, s * sizeof(int));
	if (!p) {perror("realloc"); exit(1);}

	memset(p+memlen, '\0', (s-memlen) * sizeof(int));
	mptr = (mptr-mem + p);
	mem = p;
	memlen = s;
    }

    if (ch != '>' && ch != '<') {
	*mptr++ = imov;
	imov = 0;
    }

    switch(ch) {
    default: mptr--; imov = *mptr; break; /* Hmm; oops */

    case '+': *mptr++ = T_ADD; *mptr++ = count; break;
    case '-': *mptr++ = T_ADD; *mptr++ = -count; break;
    case '<': imov -= count; break;
    case '>': imov += count; break;
    case 'X': *mptr++ = T_STOP; break;
    case ',': *mptr++ = T_INP; break;
    case '.': *mptr++ = T_PRT; break;
    case '#': *mptr++ = T_DUMP; break;

    case '[':
	{
	    struct stkdat * n = malloc(sizeof*n);
	    n->up = sp;
	    sp = n;
	    *mptr++ = T_WHL;
	    n->id = mptr-mem;
	    *mptr++ = 0;	/* Default to NOP */
	}
	break;

    case ']':
	*mptr++ = T_END;
	if (sp) {
	    struct stkdat * n = sp;
	    sp = n->up;
	    mem[n->id] = (mptr-mem) - n->id;
	    *mptr++ = -mem[n->id];
	    free(n);
	} else
	    *mptr++ = 0;	/* On error NOP */
	break;
    }
}

#if defined(__GNUC__) && ((__GNUC__>4) || (__GNUC__==4 && __GNUC_MINOR__>=4))
/* Tell GNU C to think really hard about this function! */
__attribute((optimize(3),hot,aligned(64)))
#endif
void
runprog(void)
{
    register int * p = mem;
    register icell *tp = tape;
    for(;;){
	tp += p[0];
	switch(p[1]) {
	case T_ADD: *tp += p[2]; p+=3; break;
	case T_END: if (M(*tp)!=0) p+= p[2]; p+=3; break;
	case T_WHL: if (M(*tp)==0) p+= p[2]; p+=3; break;
	case T_STOP: return;
	case T_DUMP: dumpmem(tp); p+=2; break;
#if !defined(CELLBITS) || CELLBITS >= 7
	case T_PRT: putchar(M(*tp)); p+=2; break; /* For CELLBITS=7 */
	case T_INP:
	    {
		int a;
		if((a=getchar()) != EOF) *tp = a;
		else if (on_eof != 1) *tp = on_eof;
		p+=2;
		break;
	    }
#else
	case T_PRT: printf("%d\n", M(*tp)); p+=2; break;
	case T_INP: p+=2; break;
#endif
	}
    }
}

void
dumpmem(icell *tp)
{
    int i, j = 0;
    for (i = 0; i < MEMSIZE; i++) if (M(tape[i])) j = i + 1;
    fprintf(stderr, "Ptr: %3d, mem:", (int)(tp-tape));
    for (i = 0; i < j; i++)
	fprintf(stderr, "%s%d", tape + i == tp ? ">" : " ", M(tape[i]));
    fprintf(stderr, "\n");
}
